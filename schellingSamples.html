<head>
    <!-- Plotly.js -->
    <script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
    <script src="plotly-latest.min.js"></script>
    <script src="shelling-2.js"></script>
    <script src="node_modules/seedrandom/seedrandom.min.js"></script>
  </head>
  
  <body>
    <div style="text-align: right">
      <div>
        <label for="seedText">Seed:</label><input type="text" id="seedText" />
      </div>
      <div>
        <label for="xtimesText">Number of Times:</label
        ><input type="text" id="xtimesText" />
      </div>
      <div>
        <label for="occupancyText">Occupancy:</label
        ><input type="text" id="occupancyText" />
      </div>
  
      <div>
        <label for="segmentThresholdText">Threshold:</label
        ><input type="text" id="segmentThresholdText" />
      </div>
      <div>
        <span>
          <label for="propAText">Proportion A:</label
          ><input type="text" id="propAText" />
          <label for="propBText">Proportion B:</label
          ><input type="text" id="propBText" />
        </span>
      </div>
      <div>
        <span>
          <label for="cityAText">City Dimension:</label
          ><input type="text" id="cityAText" />
        </span>
      </div>
      <button type="button" id="runSamples" onclick="runPlot()">
        click to run!
      </button>
      
    </div>
  
    <div>
      <div id="myDivX1"><!-- Plotly chart will be drawn inside this DIV --></div>
      <div>
        <label for="iterationsDiv">Iterations:</label>
        <span id="iterationsDiv"></span>
      </div>
      <div>
        <label for="segregationDiv">Average Segregation:</label>
        <span id="segregationDiv"></span>
      </div>
      <div>
        <label for="seedDiv">Seed:</label>
        <span id="seedDiv"></span>
      </div>
      <div>
        <label for="failedToStop">Failed to Stop:</label>
        <span id="failedToStop"></span>
      </div>
      <div>
        <label for="average">Average:</label>
        <span id="average"></span>
      </div>
      <div>
        <label for="paramsDiv">params = </label>
        <span id="paramsDiv"></span>
      </div>
      <div id="myDiv3"><!-- Plotly chart will be drawn inside this DIV --></div>
      <div id="myDiv4"><!-- Plotly chart will be drawn inside this DIV --></div>
    </div>
  
    <script>
      var params = {
        runXtimes: 50,
        cityHeight: 30,
        cityWidth: 30,
        occupancy: 0.9,
        populationProportions: [0, 0.6, 0.4],
        segmentRatio: 0.5,
        seed: "hello"
  
        // Seed with one 2000
        // seed: 0.8024624793347311
        // seed: "0.8051979114263961"
      };
  
      var oldSeed;
      
  
      // Make randomness repeatable
      var seedString;
      if (params.seed === "") seedString = "hello";
      else seedString = params.seed;
  
      $("#seedText").val(seedString);
      $("#xtimesText").val(params.runXtimes);
      $("#occupancyText").val(params.occupancy);
      $("#segmentThresholdText").val(params.segmentRatio);
      $("#propAText").val(params.populationProportions[1]);
      $("#propBText").val(params.populationProportions[2]);
      $("#cityAText").val(params.cityHeight);
        
      function graphPlot(divName, mat) {
        //var [howLong, segmentedCount] = runShelling(cityMat, params);
  
        // var histogramIterations = runXtimes(params);
  
        var colorscaleValue = [[0, "#ffffff"], [0.5, "#001f3f"], [1, "#edf547"]];
        var data = [
          {
            z: mat,
            type: "heatmap",
            colorscale: colorscaleValue,
            showscale: false,
            showticklabels: false
          }
        ];
  
        var axisTemplate = {
          // range: [0, 1.6],
          // autorange: false,
          showgrid: false,
          zeroline: false,
          linecolor: "black",
          showticklabels: false,
          ticks: ""
        };
  
        var layout = {
          //title: "Heatmap with Unequal Block Sizes",
          margin: {
            t: 20,
            r: 20,
            b: 20,
            l: 20
          },
          showlegend: false,
          xaxis: axisTemplate,
          yaxis: axisTemplate,
          width: 300,
          height: 300,
          autosize: false
        };
  
        Plotly.newPlot(divName, data, layout, { showSendToCloud: false });
      }
  
      function linePlot(divName, x_array, y_array, titles) {
        var trace1 = {
          x: x_array,
          y: y_array,
          mode: "lines+markers",
          type: "scatter",
        };
  
        var data = [trace1];
  
        var layout = {
          //title: "Heatmap with Unequal Block Sizes",
          margin: {
            t: 60,
            r: 60,
            b: 60,
            l: 60
          },
          // showlegend: true,
          // xaxis: axisTemplate,
          // yaxis: axisTemplate,
          width: 600,
          height: 400,
          autosize: false,
          title: {
            text: titles.main,
            // font: {
              // family: 'Courier New, monospace',
              // size: 24
            // },
            xref: 'paper',
            x: 0.05,
          },
          xaxis: {
            automargin: true,
            title: {
              text: titles.xaxis,
              font: {
                // family: 'Courier New, monospace',
                size: 18,
                color: '#7f7f7f'
              }
            },
          },
          yaxis: {
            automargin: true,
            title: {
              text: titles.yaxis,
              font: {
                // family: 'Courier New, monospace',
                size: 18,
                color: '#7f7f7f'
              }
            }
          }
        };
  
        Plotly.newPlot(divName, data, layout);
      }
  
      function histogramPlot(divName, x_array, titles) {
        var trace1 = {
          x: x_array,
          type: "histogram",
          xbins: { 
            end: .9,
            size: 0.01, 

            start: 0

        }

        };
  
        var data = [trace1];
  
        var layout = {
          //title: "Heatmap with Unequal Block Sizes",
          margin: {
            t: 60,
            r: 60,
            b: 60,
            l: 60
          },
          // showlegend: true,
          // xaxis: axisTemplate,
          // yaxis: axisTemplate,
          width: 600,
          height: 400,
          autosize: false,
          title: {
            text: titles.main,
            // font: {
              // family: 'Courier New, monospace',
              // size: 24
            // },
            xref: 'paper',
            x: 0.05,
          },
          xaxis: {
            automargin: true,
            title: {
              text: titles.xaxis,
              font: {
                // family: 'Courier New, monospace',
                size: 18,
                color: '#7f7f7f'
              }
            },
          },
          yaxis: {
            automargin: true,
            title: {
              text: titles.yaxis,
              font: {
                // family: 'Courier New, monospace',
                size: 18,
                color: '#7f7f7f'
              }
            }
          }
        };
  
        Plotly.newPlot(divName, data, layout);
      }

      function readInputs(initialParams) {
        var params = initialParams;

        if ($("#seedText").val() !== "") {
          params.seed = seedString = $("#seedText").val();
        }
  
        if ($("#xtimesText").val() !== "") {
          params.runXtimes = parseInt($("#xtimesText").val());
        }
  
        if ($("#occupancyText").val() !== "") {
          params.occupancy = $("#occupancyText").val();
        }
  
        if ($("#segmentThresholdText").val() !== "") {
          params.segmentRatio = $("#segmentThresholdText").val();
        }

        if ($("#propAText").val() !== "") {
          if (params.populationProportions === undefined) 
          params.populationProportions = [];

          params.populationProportions[1] = $("#propAText").val();
        }
        if ($("#propBText").val() !== "") {
          params.populationProportions[2] = $("#propBText").val();
        }
  
        if ($("#cityAText").val() !== "") {
          params.cityHeight = params.cityWidth = parseInt(
            $("#cityAText").val(),
            10
          );
        }
  
        
        $("#seedText").val(seedString);

        return params;
      }
  
      function runOnce(params) {
        var cityMat = Array(params.cityHeight)
          .fill()
          .map(() => Array(params.cityWidth).fill(0));
  
        populate(cityMat, params);
  
        var [iterations, segregation] = runShelling(
          cityMat,
          params,
        );
  
        return [iterations, segregation];
      }


  
      function runSamples(params) {
  
  
  
        $("#seedDiv").text(seedString);
        Math.seedrandom(seedString);
        $("#seedText").val(Math.random());
  
        var histogramIterations = [];
        
        var segregationBins = 10;
        var histogramSegregations = []

        var segregationRunningAvg = 0.0;
        var iterationsRunningAvg = 0.0;
  
        var failedToStopCount = 0;
        for (var i = 0; i < params.runXtimes; i++) {
          [iterations, segregation] = runOnce(params);
            if (iterations == -1 ) {
                failedToStopCount ++
                continue; // don't add this to the histogram

            }
          var indexI = iterations.toString();
          if (histogramIterations[indexI] == null)
            histogramIterations[indexI] = 1;
          else histogramIterations[indexI]++;

          var segregationRate = segregation.pop() /
            (params.cityHeight *
              params.cityWidth *
              params.occupancy );

          histogramSegregations.push(segregationRate)

          iterationsRunningAvg += iterations;
          segregationRunningAvg += segregationRate;
        }
  
        var averageIterations = iterationsRunningAvg/(params.runXtimes-failedToStopCount);
        var averageSegregation =  segregationRunningAvg/(params.runXtimes-failedToStopCount);
        $("#iterationsDiv").text(averageIterations);
        $("#segregationDiv").text(averageSegregation);
  
        // TODO: build a histogramIterations with the average number of iteration per population size relative to city size/ crowd size for minor or majority
        $("#paramsDiv").text(JSON.stringify(params));
        // graphPlot("myDiv2", cityMat);
  
        $("#failedToStop").text(failedToStopCount)
        // $("#failedToStop").text(failedToStopCount)
        //   //params.cityHeight * params.cityWidth * params.occupancy
        //   // Object.keys(histogramIterations)
        //   // Object.keys(histogramIterations).length
  
        //   // histogramIterations.filter(number => number !== null)
        //   function() {
        //     if (histogramIterations[2000] !== null) {
        //       return histogramIterations[2000];
        //     } else {
        //       return "none";
        //     }
        //   }
        // );
  
        delete histogramIterations[2000];
  
        $("#average").text(average(histogramIterations));
        
        var lowRange = parseInt(Object.keys(histogramIterations)[0]);
        var highRange = parseInt(Object.keys(histogramIterations).pop());

        for (var i = lowRange; i <= highRange; i++)
        {
            if (histogramIterations[i] == null ) 
            histogramIterations[i]=0;
        }


        filteredHistogram = histogramIterations.filter(number => number !== null);
        linePlot("myDiv3", Object.keys(histogramIterations), filteredHistogram,{main:'Histogram -  How Long until Equilibrium',xaxis:'Number of iterations in simulation',yaxis:'Frequency'});


        //  segregationHistogramLables = Object.keys(histogramSegregations).map(n=>n/segregationBins)
        histogramPlot("myDiv4", histogramSegregations,{main:'Histogram -  How Much Segregation at the End',xaxis:'Ending Segregation Rate',yaxis:'Frequency'});

        return {averageIterations: averageIterations, averageSegregation: averageSegregation, error: 0, errorMessage: 'no error message'};        
      }
  
      function runPlot(){
           
        params = readInputs({});
  
        runSamples(params);

      }

      runPlot();



    </script>
  </body>
  